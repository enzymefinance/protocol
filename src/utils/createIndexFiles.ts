import * as glob from 'glob';
import * as path from 'path';
import * as fs from 'fs';
import * as R from 'ramda';
import camelCase = require('camel-case');

const debug = require('./getDebug').default(__filename);

const CONTRACT_MODULES_SUBFOLDERS = ['calls', 'transactions', 'utils'];

const isContractSubfolder = candidate => {
  const parts = candidate.split(path.sep);
  const leaf = R.last(parts);
  return (
    R.contains(leaf, CONTRACT_MODULES_SUBFOLDERS) &&
    R.contains('contracts', candidate)
  );
};

const removeLeaf = directory =>
  R.init(directory.split(path.sep)).join(path.sep);

const writeAutogeneratedHeader = df => {
  fs.appendFileSync(df, '// @autogenerated\n');
  fs.appendFileSync(df, '// Please do not edit this file directly\n\n');
};

const writeExportAlls = (
  df,
  directory: string,
  absoluteSourcePaths: string[],
) => {
  absoluteSourcePaths.forEach(src => {
    const relativePath = path.relative(directory, src);
    fs.appendFileSync(df, `export * from './${relativePath.slice(0, -3)}';\n`);
  });
};

const writeExportAs = (
  df,
  directory: string,
  absoluteSourcePaths: string[],
) => {
  absoluteSourcePaths.forEach(src => {
    const relativePath = path.relative(directory, src);
    const basename = camelCase(path.basename(src));

    fs.appendFileSync(
      df,
      `import * as ${basename}Export from './${relativePath}';\n`,
    );
    fs.appendFileSync(df, `export const ${basename} = ${basename}Export;\n\n`);
  });
};

const getModuleSources = (directory, sourceFiles) =>
  R.filter(
    candidate =>
      !R.contains('.test.', candidate) &&
      !R.contains('index.ts', candidate) &&
      R.contains(directory, candidate),
  )(sourceFiles).sort();

const writeExportAllIndexFile = (directory, sourceFiles) => {
  const moduleSources = getModuleSources(directory, sourceFiles);
  const pathToIndexFile = path.join(directory, 'index.ts');
  const df = fs.openSync(pathToIndexFile, 'w');

  writeAutogeneratedHeader(df);
  writeExportAlls(df, directory, moduleSources);

  debug('Wrote:', pathToIndexFile, moduleSources.length, 'imports');

  fs.closeSync(df);
};

const writeNodeIndexFile = (directory, sourceFiles, modules) => {
  const moduleSources = getModuleSources(directory, sourceFiles);
  const directSources = R.filter(src => {
    const relativePath = path.relative(src, directory);
    const segments = relativePath.split(path.sep);
    return segments.length === 1;
  }, moduleSources);

  const childModules = R.compose(
    R.filter(R.contains(directory)),
    R.without([directory]),
  )(modules);

  const pathToIndexFile = path.join(directory, 'index.ts');
  const df = fs.openSync(pathToIndexFile, 'w');

  writeAutogeneratedHeader(df);
  writeExportAlls(df, directory, directSources);
  fs.appendFileSync(df, `\n`);
  writeExportAs(df, directory, childModules);

  debug(
    'Wrote:',
    pathToIndexFile,
    directSources.length,
    'direct imports',
    childModules.length,
    'reexports',
  );

  fs.closeSync(df);
};

const writeRootIndexFile = modules => {
  const pathToIndexFile = path.join('./src/', 'index.ts');
  const df = fs.openSync(pathToIndexFile, 'w');

  writeAutogeneratedHeader(df);
  writeExportAs(df, path.dirname(pathToIndexFile), modules);
  debug('Wrote:', pathToIndexFile, modules.length, 'reexports');

  fs.closeSync(df);
};

const isLeaf = (candidate: string, paths: string[]) => {
  const pathsWithoutCandidate = R.without([candidate], paths);
  const children = R.filter(R.contains(candidate))(pathsWithoutCandidate);
  return children.length === 0;
};

export const createIndexFiles = () => {
  debug('Starting ...');
  const sourceFiles = glob.sync('./src/**/*.ts');
  const parsedPaths = sourceFiles.map(path.parse);

  debug(sourceFiles.length, 'Source files');

  // A module is considered a directory with typescript files in it.
  const modules = R.compose(
    R.uniq,
    R.map(R.prop('dir')),
  )(parsedPaths);

  // contractModules are special because they follow the pattern with calls/
  // transactions/ utils/ in it;
  const contractModules = R.compose(
    R.uniq,
    R.map(removeLeaf),
    R.filter(isContractSubfolder),
  )(modules);

  debug(contractModules.length, 'Contract modules');

  contractModules.forEach(contractModule =>
    writeExportAllIndexFile(contractModule, sourceFiles),
  );

  const otherModules = R.filter(
    m => !R.contains('contracts', m) && m !== './src',
  )(modules);

  // Leafs are modules that do not contain subfolders
  const leafs = R.filter(candidate => isLeaf(candidate, otherModules))(
    otherModules,
  );

  leafs.forEach(directory => writeExportAllIndexFile(directory, sourceFiles));

  debug(leafs.length, 'Leaf modules');

  const nodes = R.without(leafs, otherModules);
  nodes.forEach(directory =>
    writeNodeIndexFile(directory, sourceFiles, modules),
  );

  debug(nodes.length, 'Module nodes', nodes);
  writeRootIndexFile(R.union(nodes, contractModules));
};

if (require.main === module) {
  createIndexFiles();
  // process.exit();
}
